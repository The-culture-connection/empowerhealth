rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user owns the document
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Helper function to check if user is an admin
    // Checks if user's email exists in the ADMIN collection
    // Note: This assumes ADMIN collection documents have email as a field
    // Alternative: Store admin status in user document or use hardcoded email list
    function isAdmin() {
      return isAuthenticated() && 
             request.auth.token.email != null &&
             // Check if document exists in ADMIN collection with email field matching user's email
             // Since we can't query, we'll check if email matches known admin emails
             // For production, consider storing isAdmin flag in user document
             (request.auth.token.email == 'osrgnoi@gmail.com' ||
              request.auth.token.email == 'corinntaylor@gmail.com');
    }
    
    // DEVELOPMENT MODE: More permissive rules
    // TODO: Tighten these before production
    
    // User profiles - users can read/write their own profile
    match /users/{userId} {
      allow read: if isOwner(userId);
      allow write: if isOwner(userId);
      
      // Subcollections under user profile - strict isolation
      match /visit_summaries/{summaryId} {
        allow read, write: if isOwner(userId);
        // Ensure userId matches on create
        allow create: if isOwner(userId) && 
                      request.resource.data.userId == userId;
      }
      
      match /notes/{noteId} {
        allow read, write: if isOwner(userId);
        allow create: if isOwner(userId) && 
                      request.resource.data.userId == userId;
      }
      
      match /file_uploads/{uploadId} {
        allow read, write: if isOwner(userId);
        allow create: if isOwner(userId);
      }
      
      match /learning_tasks/{taskId} {
        allow read, write: if isOwner(userId);
        allow create: if isOwner(userId) && 
                      request.resource.data.userId == userId;
      }
      
      match /{document=**} {
        allow read, write: if isOwner(userId);
      }
    }
    
    // User profiles (alternative path)
    match /profiles/{userId} {
      allow read: if isOwner(userId);
      allow write: if isOwner(userId);
    }
    
    // Learning tasks - users can manage their own tasks
    match /learning_tasks/{taskId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && 
                    request.resource.data.userId == request.auth.uid;
      allow update, delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    // Learning modules - all authenticated users can read
    match /learning_modules/{moduleId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated(); // Allow user-generated modules
      allow update, delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    // Completed tasks tracking
    match /completed_tasks/{taskId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated();
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    // Birth plans
    match /birth_plans/{planId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && 
                    request.resource.data.userId == request.auth.uid;
      allow update, delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    // Visit summaries (top-level collection) - ensure userId matches
    match /visit_summaries/{summaryId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && 
                    request.resource.data.userId == request.auth.uid;
      allow update, delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    // Journal entries (top-level collection)
    match /journal_entries/{entryId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && 
                    request.resource.data.userId == request.auth.uid;
      allow update, delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    // Journal entries (alternative path structure)
    match /journals/{userId}/entries/{entryId} {
      allow read, write: if isOwner(userId);
    }
    
    // Appointments
    match /appointments/{userId}/items/{appointmentId} {
      allow read, write: if isOwner(userId);
    }
    
    // Community posts - users can read all posts, create their own, and update to add replies/likes
    match /community_posts/{postId} {
      // Anyone authenticated can read posts
      allow read: if isAuthenticated();
      
      // Anyone authenticated can create posts (must include their userId)
      allow create: if isAuthenticated() && 
                    request.resource.data.userId == request.auth.uid &&
                    // Validate required fields
                    request.resource.data.keys().hasAll(['userId', 'content', 'createdAt']) &&
                    // Limit content length
                    request.resource.data.content is string &&
                    request.resource.data.content.size() <= 5000;
      
      // Post owners can update/delete their posts
      // Any authenticated user can update posts to add replies or toggle likes
      // TODO: In production, restrict updates to only replies/likes arrays for non-owners
      allow update: if isAuthenticated() && (
        resource.data.userId == request.auth.uid || 
        // Allow updates for adding replies or toggling likes
        // Note: This is permissive - consider tightening in production
        true
      );
      
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    // Post reports - users can create reports, admins can read
    match /post_reports/{reportId} {
      // Users can create reports
      allow create: if isAuthenticated() && 
                    request.resource.data.userId == request.auth.uid &&
                    request.resource.data.keys().hasAll(['userId', 'postId', 'reason', 'createdAt']);
      
      // Users can read their own reports
      // TODO: Add admin role check for reading all reports
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      
      // No updates or deletes allowed
      allow update, delete: if false;
    }
    
    // Community comments (legacy - keeping for backwards compatibility)
    match /community/{postId}/comments/{commentId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated();
      allow update, delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    // Messages
    match /messages/{conversationId} {
      allow read, write: if isAuthenticated();
    }
    
    // Module reviews - users can create reviews and read/update/delete their own
    match /module_reviews/{reviewId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    // Module feedback - users can create feedback and read/update/delete their own
    match /ModuleFeedback/{feedbackId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && 
                    request.resource.data.userId == request.auth.uid &&
                    request.resource.data.keys().hasAll(['userId', 'moduleTitle', 'understandingRating', 'nextStepsRating', 'confidenceRating', 'createdAt']);
      allow update, delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    // Provider Search Collections
    
    // Providers - all authenticated users can read
    match /providers/{providerId} {
      allow read: if isAuthenticated();
      
      // Anyone can create providers (for review submissions)
      allow create: if isAuthenticated() &&
                    request.resource.data.keys().hasAll(['name', 'createdAt']);
      
      // Updates: Regular users can update their own provider data (from reviews)
      // Admins can update any provider, including mamaApproved field
      allow update: if isAuthenticated() && (
        // Admin can update anything, including mamaApproved
        isAdmin() ||
        // Regular users can update but cannot set/change mamaApproved
        (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['mamaApproved', 'mamaApprovedCount']))
      );
      
      // Only admins can delete providers
      allow delete: if isAdmin();
    }
    
    // Provider reviews - users can read all, create their own, update/delete their own
    match /reviews/{reviewId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && 
                    request.resource.data.userId == request.auth.uid &&
                    request.resource.data.keys().hasAll(['providerId', 'userId', 'rating', 'createdAt']);
      allow update, delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    // Provider submissions - users can create, admins can read/update
    match /provider_submissions/{submissionId} {
      allow create: if isAuthenticated() && 
                    request.resource.data.keys().hasAll(['provider', 'status', 'createdAt']);
      // Users can read their own submissions
      allow read: if isAuthenticated() && (
        resource.data.submittedBy == request.auth.uid ||
        // TODO: Add admin role check
        true
      );
      // Only admins can update (for moderation)
      // TODO: Implement admin role check
      allow update: if isAuthenticated();
      allow delete: if false;
    }
    
    // User-provided providers - users can create and read their own
    match /UserProviders/{providerId} {
      allow create: if isAuthenticated() && 
                    request.resource.data.userId == request.auth.uid &&
                    request.resource.data.keys().hasAll(['name', 'createdAt']);
      allow read: if isAuthenticated() && (
        resource.data.submittedBy == request.auth.uid ||
        // Admins can read all
        isAdmin()
      );
      // Only admins can update/delete (for moderation)
      allow update, delete: if isAdmin();
    }
    
    // Saved providers - users can manage their own favorites
    match /users/{userId}/saved_providers/{providerId} {
      allow read, write: if isOwner(userId);
    }
    
    // Identity tags - all authenticated users can read
    match /identity_tags/{tagId} {
      allow read: if isAuthenticated();
      // Only admins can write
      // TODO: Implement admin role check
      allow write: if isAuthenticated();
    }
    
    // Provider identity claims - users can create, read their own, admins can read all
    match /provider_identity_claims/{claimId} {
      allow create: if isAuthenticated() && 
                    request.resource.data.keys().hasAll(['providerId', 'userId', 'tagId', 'status', 'createdAt']);
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        // TODO: Add admin role check
        true
      );
      // Only admins can update (for verification)
      // TODO: Implement admin role check
      allow update: if isAuthenticated();
      allow delete: if false;
    }
    
    // ADMIN collection - users can check if their email exists (for admin status check)
    match /ADMIN/{adminId} {
      // Allow authenticated users to read documents where email matches their own
      // This allows the app to check if a user is an admin
      allow read: if isAuthenticated() && 
                  request.auth.token.email != null &&
                  resource.data.email == request.auth.token.email;
      // Only admins can write to ADMIN collection
      allow write: if isAdmin();
    }
  }
}
